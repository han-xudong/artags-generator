import { jsPDF } from "jspdf";
import { saveAs } from "file-saver";

/**

 * @param {HTMLCanvasElement} canvas
 * @param {string} filename
 */
export const exportAsSVG = (canvas, filename, tagSize, margin) => {
  try {
    const width = canvas.width;
    const height = canvas.height;
    const size = tagSize + 2 * margin;

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size + "mm");
    svg.setAttribute("height", size + "mm");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, width, height);
    const pixels = imageData.data;

    const cellSize = detectCellSize(pixels, width, height);

    if (cellSize > 1) {
      for (let y = 0; y < height; y += cellSize) {
        for (let x = 0; x < width; x += cellSize) {
          let isBlack = false;

          const centerX = Math.floor(x + cellSize / 2);
          const centerY = Math.floor(y + cellSize / 2);

          if (centerX < width && centerY < height) {
            const index = (centerY * width + centerX) * 4;
            isBlack = pixels[index] < 128;

            if (isBlack) {
              const rect = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
              rect.setAttribute("x", x);
              rect.setAttribute("y", y);
              rect.setAttribute("width", cellSize);
              rect.setAttribute("height", cellSize);
              rect.setAttribute("fill", "black");
              svg.appendChild(rect);
            }
          }
        }
      }

      const background = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "rect"
      );
      background.setAttribute("x", 0);
      background.setAttribute("y", 0);
      background.setAttribute("width", width);
      background.setAttribute("height", height);
      background.setAttribute("fill", "white");
      svg.insertBefore(background, svg.firstChild);
    } else {
      const img = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "image"
      );
      img.setAttribute("width", width);
      img.setAttribute("height", height);
      img.setAttribute("href", canvas.toDataURL("image/png"));
      svg.appendChild(img);
    }

    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(svg);

    const svgBlob = new Blob(
      [
        '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n',
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n',
        svgString,
      ],
      { type: "image/svg+xml" }
    );

    saveAs(svgBlob, `${filename}.svg`);
  } catch (error) {
    console.error("Error exporting SVG:", error);
    alert("Failed to export SVG. See console for details.");
  }
};

/**
 * @param {HTMLCanvasElement} canvas
 * @param {string} filename
 */
export const exportAsPDF = (canvas, filename, tagSize, margin) => {
  try {
    const width = canvas.width;
    const height = canvas.height;

    const widthMM = tagSize + 2 * margin;
    const heightMM = tagSize + 2 * margin;

    const doc = new jsPDF({
      orientation: width > height ? "landscape" : "portrait",
      unit: "mm",
      format: [widthMM + 20, heightMM + 20],
    });

    const imgData = canvas.toDataURL("image/png", 1.0);
    doc.addImage(imgData, "PNG", 10, 10, widthMM, heightMM);

    doc.setFontSize(8);
    doc.text(
      `${filename} - Generated by Tag Generator Tool`,
      10,
      heightMM + 15
    );

    doc.save(`${filename}.pdf`);
  } catch (error) {
    console.error("Error exporting PDF:", error);
    alert("Failed to export PDF. See console for details.");
  }
};

/**

 * @param {HTMLCanvasElement} canvas
 * @param {string} filename
 */
export const exportAsPNG = (canvas, filename) => {
  try {
    canvas.toBlob((blob) => {
      if (blob) {
        saveAs(blob, `${filename}.png`);
      } else {
        throw new Error("Could not create image blob");
      }
    }, "image/png");
  } catch (error) {
    console.error("Error exporting PNG:", error);
    alert("Failed to export PNG. See console for details.");
  }
};

/**
 * @param {Uint8ClampedArray} pixels
 * @param {number} width
 * @param {number} height
 * @returns {number}
 */
const detectCellSize = (pixels, width, height) => {
  try {
    let startX = -1;
    let startY = -1;

    for (let y = 0; y < height && startY === -1; y++) {
      for (let x = 0; x < width && startX === -1; x++) {
        const index = (y * width + x) * 4;
        if (pixels[index] < 128) {
          startX = x;
          startY = y;
          break;
        }
      }
    }

    if (startX === -1 || startY === -1) return 0;

    let endX = startX;
    while (endX < width) {
      const index = (startY * width + endX) * 4;
      if (pixels[index] >= 128) break;
      endX++;
    }

    const cellSize = endX - startX;

    if (cellSize < 2 || cellSize > Math.min(width, height) / 4) {
      return 0;
    }

    return cellSize;
  } catch (error) {
    console.error("Error detecting cell size:", error);
    return 0;
  }
};
